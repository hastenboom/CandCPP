# 一 一维数组传参
```
void test(int arr[]);//ok
void test(int arr[10]);//写不写无所谓
void test(int *arr);//ok

void test2(int *arr[]);//ok
void test2(int *arr[20]);//ok
void test2(int **arr);//ok


int main()
{
    int arr[10]={0};
    int *arr2[20] = {0};
    test(arr);
    test2(arr2);
}
```
# 二 二维数组传参
```
//测试用时请注意修改 
void test(int arr[3][5]);
void test(int arr[][5]);
void test(int arr[3][]);//error，列不能省略

void test(int *arr);//error,arr此时是一个数组，只能传入数组指针
void test(int ** arr);//error,二级指针存放的是一级指针的地址，但是二维的arr是一个数组，所以int **arr不能传参
void test(int (*arr)[5]);

int main()
{
    int arr[3][5]={0};
    test(arr);
    return 0;
}
```
# 三 一级指针传参
```
void test(int *p);
void test1(int *p);

int main()
{
    int arr[5]={0};
    int *p = arr;
    //arr首元素
    test(p);

    int a =10;
    int * p1 = &a;
    test1(&a);
    test1(p1);
   
    return 0;
}
```

# 四 二级指针传参
>类似一级指针，不述。需要注意的是可以传递指针数组：
```
//伪
void test(int **p);
test(int *arr[10]);
```

# 五 函数的指针
```
int Add(int x,int y)
{
    int z =0;
    z = x+y;
    return z;
}

int main()
{
    int a =10;
    int b =20;
    cout<<Add(a,b);
    
    if(Add==&Add)
    {
        cout<<"都是函数的地址";
    }

    int (*pa)(int,int)=&Add//这就是函数指针
    cout<<(*pa)(a,b);
    //实际上直接用pa(a,b)是可以的，因为Add==&Add，但是不易于阅读


    return 0;
}
```
>两段莫名其妙的代码，出自《C陷阱和缺陷》
```
(*(void(*)())0)();

//(*解除引用，引用0的地址    (void(*)() //函数指针，一种类型   )//强转换    0)();
//void(*)()这是一个函数指针，地址
//外面套一层（），为强制类型转换，如:int a = (int)3.14 
//此处强制转换int 0为void(*)()类型，函数的地址
//外层的*是解除，使用函数，调动0地址处的函数

//-----------------------------------

void (*signal(int,void(*)(int)))(int);

//signal(int, void(*)(int) )，传了个函数指针进去，signal是函数，param，ok，返回是什么呢？
//去除这段，剩下 void(*)(int),这个是返回值，这也是一个函数指针
//void(*)(int) signal(balabala)这个返回方式是错的

//简化
typedef void(*)(int) pfu_t;//error

typedef void(*pfu_t)(int);
pfun_t signal(int,pfun_t);
```

# 五 函数指针数组


```
int ADD(int a, int b)
{
    return 0;
}
int SUB(int a, int b)
{
    return 1;
}
int MUL(int a, int b)
{
    return 2;
}

int main()
{
    int *arr[5];

    int (*pfun[3])(int, int) = {ADD, SUB, MUL};
    // ADD,SUB要写完整不能只有原型，只有输入和输出类型一致时才能这么操作

    for (int i = 0; i < 3; i++)
    {
        cout << (*pfun[i])(1, 2);
    }
    system("pause");
    return 0;
}
```
```
char *my_strcpy(char *dest, const char *src)
{
    return dest;
}

int main()
{
    //function pointer
    char *(*pf)(char *, const char *);
    
    //function pointer array
    char *(*parr_f[4])(char *, const char *) =
        {my_strcpy, my_strcpy, my_strcpy, my_strcpy};

    return 0;
}
```
>错误声明
```
int *parr2[10]();
int (*)()parr3[10];

//正确的做法是，先声明数组，然后指针，然后括号，最后函数形式
void (*parr_fun[10])(int,int);
```