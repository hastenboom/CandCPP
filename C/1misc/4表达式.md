表达式求值与整型提升
>表达式的求值依赖于括号与自身运算的优先级，同时还依赖于运算中可能出现的类型转换（隐式转换），如整型提升。下列解释整形提升。
```
 
int main()
{
    //只要类型小于4Bytes，就要发生整型提升
    //3 = 00000000 00000000 00000000 00000011
    //因为正数三码合一，所以截断后 a = 00000011   
    char a = 3;
    //127 = 00000000 00000000 00000000 01111111，同理截断后b = 011111111
    char b =127;

    //此时在运算时！发生整型提升，根据符号位补，a是0，b也是0，
    //此时 a = 00000000 00000000 00000000 00000011;
    //     b = 00000000 00000000 00000000 01111111；
    //   a+b = 00000000 00000000 00000000 10000010
    //然后截断（因为char c），a+b = 10000010
    
    //因为char c不是unsigned，所以首位当作符号位，所以要进行补码->原码，此时(int)c = 11111110 = -126
    char c = a+b;

    cout<<(int)c<<endl;

    return 0;
}
```
>整型提升的另一个例子
```
int main()
{
    char a =0xb6;
    short b = 0xb600;
    int c= 0xb6000000;
    if(a==oxb6)
    {
        cout<<a;
    }
    if(b==0xb600)
    {
        cout<<b;
    }
    if(c==0xb6000000)
    {
        cout<<c;
    }
    //因为发生了整型提升，所以只有
    return 0;
}
```
---